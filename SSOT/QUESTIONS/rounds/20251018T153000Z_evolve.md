# Question Evolution Snapshot — 20251018T153000Z

## Meta
- Round: 20251018T153000Z
- Phase: Q_AND_E
- Generated: 2025-10-18T15:30:00Z
- Strategy: Architecture-complete foundation questions based on AGENT.md analysis
- Focus: Critical path components (C01, C02, C03, C04, C05, C07, C10, C12, C13, C16) prioritized

## Foundation Questions (Architecture-Complete)

### Q_040: Idempotency Keys Across All Write Operations
**Hypothesis:** All agents that write to SSOT or external APIs must use idempotency keys to prevent duplicate operations during retries.
**Why it matters:** Kafka retries, network failures, and replays can cause duplicate writes leading to data corruption, double-billing, or inconsistent state.
**Expected impact:** Prevents duplicate budget allocations ($50k+ duplicate spend risk), duplicate ad creations, duplicate user profiles, and duplicate metric writes.
**How to verify:** 
- Unit tests: Send same operation twice with same idempotency key, verify single execution
- Integration tests: Simulate Kafka replay with duplicate events, verify deduplication
- Acceptance: All agents in C13_BudgetAllocation, C14_ActivationAgent, C01_IdentityResolution, C02_DataQuality use idempotency keys
**Proposed change:**
- Add `IdempotencyService` class with Redis-backed key storage (TTL=7d)
- Implement `@idempotent(key_fn=...)` decorator for all write operations
- Add idempotency_key field to all write DTOs (BudgetAllocation, ActivationCommand, etc.)
**Targets:** ["core/idempotency.py", "agents/budget_allocation.py", "agents/activation.py", "core/message_bus.py"]
**Urgency:** P0
**Owner:** Execution
**Related:** ["Q_027", "A_004", "A_005"]

### Q_041: Circuit Breakers for External API Calls
**Hypothesis:** All external API calls (ad platforms, LLM APIs, secret managers) need circuit breakers to prevent cascade failures and cost overruns.
**Why it matters:** A failing Meta Ads API endpoint could cause retry storms consuming entire LLM budget ($1000s) or blocking all operations.
**Expected impact:** Limits blast radius of external failures; prevents cost overruns; maintains system stability during partner outages.
**How to verify:**
- Unit tests: Mock failing API, verify circuit opens after threshold
- Integration tests: Simulate API timeout/errors, verify graceful degradation
- Acceptance: All external clients (AdPlatformAgent, LLMClient, SecretManagerClient) have circuit breakers with configurable thresholds
**Proposed change:**
- Add `CircuitBreaker` class with states (CLOSED, OPEN, HALF_OPEN)
- Implement thresholds: failure_rate=0.5, window=60s, timeout=30s, max_retries=3
- Wrap all external API calls with `@circuit_breaker(name=...)`
- Emit metrics: circuit_breaker_state_changes, circuit_breaker_failures
**Targets:** ["core/circuit_breaker.py", "agents/ad_platform_agent.py", "agents/llm_client.py", "core/security.py"]
**Urgency:** P0
**Owner:** Infra
**Related:** ["A_013_NEW"]

### Q_042: Distributed Tracing with Correlation IDs
**Hypothesis:** Every request must carry a correlation_id through the entire execution path for debugging and audit.
**Why it matters:** Without correlation IDs, debugging multi-agent workflows (Q→Audit→Execute) is impossible; GDPR requires full audit trails.
**Expected impact:** Enables end-to-end debugging; satisfies audit requirements; reduces incident MTTR from hours to minutes.
**How to verify:**
- Unit tests: Verify correlation_id propagates through event handlers
- Integration tests: Trigger playbook, verify all logs/spans share correlation_id
- Acceptance: All logs, metrics, and traces include correlation_id; OpenTelemetry spans linked
**Proposed change:**
- Add correlation_id to all Event types
- Implement middleware to extract/inject correlation_id from headers
- Add correlation_id to all log statements (structured logging)
- Configure OpenTelemetry to propagate trace context
**Targets:** ["core/event.py", "core/logging.py", "core/tracing.py", "agents/master_coordinator.py"]
**Urgency:** P0
**Owner:** Infra
**Related:** ["A_014_NEW"]

### Q_043: Schema Versioning for All Contracts
**Hypothesis:** All data contracts (Events, DTOs, API requests/responses) must be versioned to enable backward-compatible evolution.
**Why it matters:** Schema changes without versioning break existing consumers; causes production incidents; blocks gradual rollouts.
**Expected impact:** Enables zero-downtime deployments; allows A/B testing of schema changes; prevents breaking changes.
**How to verify:**
- Unit tests: Deserialize old schema version, verify compatibility
- Integration tests: Send v1 event to v2 handler, verify successful processing
- Acceptance: All Pydantic models have version field; validation enforces version compatibility
**Proposed change:**
- Add `schema_version` field to all BaseModel classes
- Implement version compatibility checks in validation layer
- Add schema registry with version history
- Document migration paths for each version increment
**Targets:** ["core/contracts.py", "core/schema_validator.py", "agents/schema_validator.py"]
**Urgency:** P0
**Owner:** DataOps
**Related:** ["A_010"]

### Q_044: Feature Store Serving Layer Latency SLA <50ms
**Hypothesis:** Online feature serving must return features in <50ms p95 to enable real-time decisions without blocking requests.
**Why it matters:** Slow feature lookups block budget allocation, bid adjustments, and creative rotation; degrades user experience.
**Expected impact:** Enables real-time decisioning; prevents timeout cascades; maintains system responsiveness under load.
**How to verify:**
- Performance tests: Load test feature store with 1000 QPS, verify p95 <50ms
- Integration tests: Measure end-to-end latency from event to feature retrieval
- Acceptance: All feature_store.get() calls complete in <50ms p95; emit latency metrics
**Proposed change:**
- Implement Redis caching layer for hot features (TTL=5min)
- Add precomputation for frequently accessed aggregations
- Optimize database queries with proper indexing
- Add latency monitoring with alerts on SLA breach
**Targets:** ["core/feature_store.py", "tests/test_feature_store_performance.py"]
**Urgency:** P1
**Owner:** DataOps
**Related:** ["A_008", "Q_025"]

### Q_045: MMM Model Drift Detection
**Hypothesis:** MMM models must be monitored for drift (accuracy degradation) and auto-retrained when drift exceeds threshold.
**Why it matters:** Stale models give incorrect ROAS estimates leading to misallocated budgets (10-30% waste).
**Expected impact:** Maintains model accuracy >85% MAPE; prevents budget misallocation; automates model freshness.
**How to verify:**
- Unit tests: Simulate data distribution shift, verify drift detection triggers
- Integration tests: Run model on old data, verify MAPE increase triggers retraining
- Acceptance: Weekly MAPE validation; auto-retrain if MAPE >15%; alert on 3 consecutive degradations
**Proposed change:**
- Add `ModelMonitor` class to track prediction accuracy vs actuals
- Implement drift metrics: MAPE, distribution distance (KL divergence)
- Add auto-retrain trigger with configurable thresholds
- Store model versions with performance history
**Targets:** ["agents/mmm_agent.py", "agents/model_monitor.py", "tests/test_model_drift.py"]
**Urgency:** P1
**Owner:** Analytics
**Related:** ["A_009", "Q_028"]

### Q_046: Audit Log Immutability and Retention
**Hypothesis:** All audit logs must be immutable (append-only) and retained for 7 years per compliance requirements.
**Why it matters:** Mutable logs can be tampered with; insufficient retention violates GDPR/SOC2/financial regulations.
**Expected impact:** Satisfies compliance audits; prevents evidence tampering; enables forensic analysis.
**How to verify:**
- Unit tests: Attempt to modify existing audit record, verify rejection
- Integration tests: Write audit log, verify immutability guarantees
- Acceptance: Audit logs stored in append-only table/storage; retention policy=7yr; automated backups
**Proposed change:**
- Migrate audit_log table to append-only design (no UPDATE, DELETE)
- Add write-once storage backend (GCS with retention policy or S3 Object Lock)
- Implement automated archival to cold storage after 90d
- Add integrity checks (hash chains) to detect tampering
**Targets:** ["core/audit.py", "infrastructure/storage.py", "tests/test_audit_immutability.py"]
**Urgency:** P1
**Owner:** Compliance
**Related:** ["A_015_NEW"]

### Q_047: Playbook Dry-Run Mode
**Hypothesis:** All playbooks must support dry-run mode to preview changes before execution, with full rollback capability.
**Why it matters:** Expensive mistakes (pausing wrong campaigns, deleting live assets) are hard to undo; need safety net.
**Expected impact:** Prevents production incidents; enables testing of playbook logic; builds operator confidence.
**How to verify:**
- Unit tests: Execute playbook in dry-run mode, verify no mutations
- Integration tests: Dry-run budget reallocation, verify preview matches actual
- Acceptance: All playbooks support `dry_run=true` flag; output preview of changes; no side effects
**Proposed change:**
- Add `dry_run` parameter to all playbook steps
- Implement preview mode that simulates changes without writes
- Add diff output showing current state → proposed state
- Store dry-run results for audit
**Targets:** ["agents/playbook_orchestrator.py", "agents/activation_agent.py", "tests/test_playbook_dry_run.py"]
**Urgency:** P1
**Owner:** Execution
**Related:** ["A_011", "Q_031"]

### Q_048: Multi-Currency Support in Revenue Tracking
**Hypothesis:** All revenue and spend must be stored with original currency + USD normalized value for accurate global reporting.
**Why it matters:** Currency conversions at report time use wrong exchange rates; causes 5-10% revenue misreporting.
**Expected impact:** Accurate multi-market financial reporting; correct ROI calculations across regions; satisfies financial audit.
**How to verify:**
- Unit tests: Store revenue in JPY, verify USD conversion at historical rate
- Integration tests: Aggregate revenue across markets, verify correct totals
- Acceptance: All monetary fields have currency code; USD_normalized fields computed at ingestion with historical FX rates
**Proposed change:**
- Add currency code to all monetary schemas (Order, SpendRecord, BudgetAllocation)
- Implement FX rate service with historical rates (daily snapshots)
- Add USD normalization at ingestion time (not query time)
- Store both original amount + USD normalized in SSOT
**Targets:** ["core/contracts.py", "core/fx_rates.py", "agents/ingestion_agent.py", "tests/test_multi_currency.py"]
**Urgency:** P1
**Owner:** DataOps
**Related:** ["A_016_NEW"]

### Q_049: Rate Limiting for All External APIs
**Hypothesis:** All external API clients must implement rate limiting to respect partner quotas and prevent throttling/bans.
**Why it matters:** Exceeding Meta/Google API rate limits causes 24h bans; interrupts all operations; loses revenue.
**Expected impact:** Prevents API bans; maintains stable operations; respects partner SLAs; reduces API costs.
**How to verify:**
- Unit tests: Mock rate limiter, verify requests queued when limit reached
- Integration tests: Send burst requests, verify graceful queueing
- Acceptance: All external clients have rate limiters; emit metrics on throttling; configurable per-partner limits
**Proposed change:**
- Add `RateLimiter` class with token bucket algorithm
- Configure limits per API: Meta=200/hr, Google=10k/day, LLM=100/min
- Implement request queuing with backoff
- Add metrics: rate_limit_hits, queued_requests, throttle_duration
**Targets:** ["core/rate_limiter.py", "agents/ad_platform_agent.py", "agents/llm_client.py", "tests/test_rate_limiter.py"]
**Urgency:** P1
**Owner:** Infra
**Related:** ["A_017_NEW"]

### Q_050: Creative Asset Fingerprinting for Duplicate Detection
**Hypothesis:** All creative assets must be fingerprinted (perceptual hash for images, text hash for copy) to prevent duplicate uploads and wasted spend.
**Why it matters:** Duplicate assets dilute frequency capping; cause internal competition; waste 5-15% of creative budget.
**Expected impact:** Prevents duplicate uploads; optimizes creative rotation; reduces creative production costs.
**How to verify:**
- Unit tests: Hash identical images, verify same fingerprint; hash similar images, verify similarity score
- Integration tests: Upload duplicate asset, verify rejection with reference to existing
- Acceptance: All assets have fingerprint; duplicate check before upload; similarity threshold=0.95
**Proposed change:**
- Add `AssetFingerprint` service with perceptual hashing (pHash for images, SimHash for text)
- Implement duplicate detection at ingestion (before upload to ad platform)
- Store fingerprints in asset metadata
- Add similarity search to find near-duplicates
**Targets:** ["agents/creative_intelligence.py", "core/asset_fingerprint.py", "tests/test_asset_fingerprint.py"]
**Urgency:** P2
**Owner:** Creative
**Related:** ["A_018_NEW"]

## Clarity Assessment

All questions follow required structure:
- ✅ `hypothesis`: Clear statement of what needs to be true
- ✅ `why_it_matters`: Business/technical impact explained
- ✅ `expected_impact`: Quantified or specific outcomes
- ✅ `how_to_verify`: Concrete acceptance criteria with test types
- ✅ `proposed_change`: Specific implementation approach with files
- ✅ `targets`: Exact file paths specified
- ✅ `urgency`: P0/P1/P2 assigned based on severity and dependency
- ✅ `owner`: Responsibility assigned to team/domain
- ✅ `related`: Links to relevant audits and questions

**Clarity Score:** 11/11 clear (100%)
**Unclear Count:** 0

## Prioritization Summary

### P0 Critical Path (Must Have for MVP)
- Q_040: Idempotency Keys (Execution safety)
- Q_041: Circuit Breakers (Cost control + stability)
- Q_042: Distributed Tracing (Debuggability + audit)
- Q_043: Schema Versioning (Evolution safety)

### P1 Production Readiness (Should Have)
- Q_044: Feature Store Latency (Performance)
- Q_045: MMM Model Drift (Accuracy)
- Q_046: Audit Log Immutability (Compliance)
- Q_047: Playbook Dry-Run (Safety)
- Q_048: Multi-Currency (Accuracy)
- Q_049: Rate Limiting (Stability)

### P2 Optimization (Nice to Have)
- Q_050: Asset Fingerprinting (Efficiency)

## Dependencies

```
Q_040 → (enables) → Q_047 (dry-run needs idempotency)
Q_041 → (enables) → Q_049 (rate limiter needs circuit breaker)
Q_042 → (enables) → Q_046 (audit needs correlation IDs)
Q_043 → (blocks) → All schema changes
```

## Gap Analysis

### Missing from Previous Rounds
- **Idempotency:** Only Q_027 addressed deduplication; Q_040 extends to all write operations
- **Circuit Breakers:** Not previously covered; critical for external API reliability
- **Distributed Tracing:** Not previously covered; critical for multi-agent debugging
- **Schema Versioning:** Q_030 addressed drift detection; Q_043 adds version management
- **Multi-Currency:** Not previously covered; critical for global operations
- **Rate Limiting:** Not previously covered; critical for API partnership health

### New Audits Implied
- A_013_NEW: Circuit breaker coverage for all external APIs
- A_014_NEW: Correlation ID propagation across all components
- A_015_NEW: Audit log immutability and retention compliance
- A_016_NEW: Multi-currency revenue tracking accuracy
- A_017_NEW: Rate limiter configuration for all partners
- A_018_NEW: Creative asset fingerprinting and duplicate detection

## Next Round Hints

1. After Q_040-Q_043 (P0) are done → implement Q_044-Q_047 (P1 production readiness)
2. Schema versioning (Q_043) unblocks all data contract evolution
3. Circuit breakers (Q_041) + Rate limiting (Q_049) form resilience layer
4. Distributed tracing (Q_042) enables debugging of all above

## Snapshot Statistics
- Total questions: 11
- P0: 4 (36%)
- P1: 6 (55%)
- P2: 1 (9%)
- Clear: 11 (100%)
- Components covered: C01, C02, C03, C04, C10, C13, C14, C16, Infra, Compliance, Creative
- New audits implied: 6
