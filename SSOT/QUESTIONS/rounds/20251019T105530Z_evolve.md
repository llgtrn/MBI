{
  "questions": [
    {
      "id": "Q_401",
      "area": "Data",
      "question": "What DB transaction isolation level ensures identity hash merge atomicity without deadlock risk?",
      "why_it_matters": "C01 Red/CRIT; Q_001 test exists but impl needs isolation guarantee for concurrent merge ops",
      "evidence_anchor": ["agents/identity_resolution_agent.py", "tests/agents/test_identity_resolution_agent.py"],
      "acceptance_signal": "Schema: transaction isolation = SERIALIZABLE or optimistic lock version field with retry",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_402",
      "area": "Data",
      "question": "How does salt rotation handle in-flight identity resolution requests during the 7-day grace window?",
      "why_it_matters": "C01 Red/CRIT; Q_102 test exists; need impl for dual-key lookup strategy to prevent orphaned hashes",
      "evidence_anchor": ["core/privacy.py", "agents/identity_resolution_agent.py"],
      "acceptance_signal": "Code: old_salt fallback for requests within grace_window; metric grace_window_fallback_rate",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_403",
      "area": "Strategy",
      "question": "What triggers MMM model retraining outside the weekly schedule when MAPE validation fails?",
      "why_it_matters": "C04 Red/HIGH; Q_009 test exists for 15% gate; need impl for adaptive retraining on drift detection",
      "evidence_anchor": ["agents/mmm_agent.py", "tests/agents/test_mmm_agent.py"],
      "acceptance_signal": "Code: drift detector triggers immediate retrain if validation MAPE >15% or residual autocorrelation",
      "urgency": "P0",
      "owner_hint": "Execution"
    },
    {
      "id": "Q_404",
      "area": "Observability",
      "question": "What distributed trace span attributes capture MMM training start-to-deploy latency for performance SLA?",
      "why_it_matters": "C04 Red/HIGH; missing Observability artifact; need trace instrumentation for 6h training SLA",
      "evidence_anchor": ["agents/mmm_agent.py", "core/observability.py"],
      "acceptance_signal": "Trace: span 'mmm_train' with attributes {model_version, lookback_weeks, channel_count, duration_ms}",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_405",
      "area": "Data",
      "question": "How does MTA path builder handle user_key hash collision when k-anonymity suppression is active?",
      "why_it_matters": "C05 Red/CRIT; Q_010+Q_044 deferred impl; need collision handling strategy to maintain k>=10 guarantee",
      "evidence_anchor": ["agents/mta_agent.py", "core/privacy.py"],
      "acceptance_signal": "Code: collision detection via bloom filter; suppress both paths if collision detected within k-anon group",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_406",
      "area": "Observability",
      "question": "What metric tracks MTA conversion path reconstruction success rate to detect data loss?",
      "why_it_matters": "C05 Red/CRIT; missing Observability artifact; silent path drops (Q_010) need detection",
      "evidence_anchor": ["agents/mta_agent.py", "core/metrics.py"],
      "acceptance_signal": "Metric: mta_path_reconstruction_rate{status=success|partial|failed} with p95<1% failed",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_407",
      "area": "Infra",
      "question": "What backup strategy ensures MTA transition matrix recovery if primary Redis instance fails?",
      "why_it_matters": "C05 Red/CRIT; MTA stores ephemeral transition state; need persistence strategy for disaster recovery",
      "evidence_anchor": ["agents/mta_agent.py", "infra/redis.yml"],
      "acceptance_signal": "Config: Redis AOF persistence enabled; daily snapshot to S3; RTO <30min",
      "urgency": "P0",
      "owner_hint": "Infra"
    },
    {
      "id": "Q_408",
      "area": "Risk",
      "question": "What LLM temperature enforcement occurs at middleware ingress before enrichment to prevent bypass?",
      "why_it_matters": "C10 Red/CRIT; Q_015 timing vulnerability; middleware must validate before any LLM context enrichment",
      "evidence_anchor": ["middleware/llm_guard.py", "agents/llm_council.py"],
      "acceptance_signal": "Code: guard checks temp in first middleware layer; rejects if temp>0.2 before retrieval",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_409",
      "area": "Governance",
      "question": "How does LLM source_ids validator distinguish between unique domains vs unique URLs for 2-source rule?",
      "why_it_matters": "C10 Red/CRIT; Q_016 requires domain-level uniqueness; need FQDN extraction and dedup logic",
      "evidence_anchor": ["agents/llm_council.py", "schemas/llm_output.zod.ts"],
      "acceptance_signal": "Code: extract domain from URL; validate unique_domains(source_ids) >= 2; test with subdomain variants",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_410",
      "area": "Secrets",
      "question": "What KMS key rotation schedule ensures Analyst and Verifier LLM API keys never expire simultaneously?",
      "why_it_matters": "C10 Red/CRIT; Q_017 requires staggered rotation; need automated schedule to prevent dual outage",
      "evidence_anchor": ["agents/llm_council.py", "core/secrets.py"],
      "acceptance_signal": "Config: analyst_key_ttl=30d, verifier_key_ttl=45d; cron triggers at different weeks",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_411",
      "area": "Governance",
      "question": "What defines tier-1 vs tier-2 sources in crisis detection domain whitelist and how often is it audited?",
      "why_it_matters": "C11 Red/CRIT; Q_018 requires tier-1 classification; need governance process for whitelist updates",
      "evidence_anchor": ["agents/crisis_detection_agent.py", "config/official_domains.yml"],
      "acceptance_signal": "Doc: tier-1 = official brand domains + verified news orgs; quarterly audit; changelog in repo",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_412",
      "area": "Strategy",
      "question": "How does crisis velocity baseline calculation handle weekend/holiday traffic dips to avoid false positives?",
      "why_it_matters": "C11 Red/CRIT; Q_019 baseline drift; need day-of-week normalization to prevent spurious alerts",
      "evidence_anchor": ["agents/crisis_detection_agent.py", "core/metrics.py"],
      "acceptance_signal": "Code: rolling 28d baseline excludes holidays; day-of-week multipliers applied; metric baseline_adjusted",
      "urgency": "P0",
      "owner_hint": "Execution"
    },
    {
      "id": "Q_413",
      "area": "Compliance",
      "question": "What COPPA parent email verification flow prevents minor from circumventing by using parent's email directly?",
      "why_it_matters": "C12 Red/CRIT; Q_020 dual validation requires challenge-response; need impl for email challenge",
      "evidence_anchor": ["middleware/compliance_guard.py", "agents/compliance_agent.py"],
      "acceptance_signal": "Code: send verification link to parent_email; token expires 24h; minor cannot proceed without parent click",
      "urgency": "P0",
      "owner_hint": "Compliance"
    },
    {
      "id": "Q_414",
      "area": "Compliance",
      "question": "How does Japan promo label detection handle mixed visual+metadata signals when they conflict?",
      "why_it_matters": "C12 Red/CRIT; Q_021 requires visual analysis; need precedence rule if OCR says promo but metadata doesn't",
      "evidence_anchor": ["agents/compliance_agent.py", "models/vision.py"],
      "acceptance_signal": "Config: visual_overrides_metadata=true; if OCR detects 'åºƒå'Š', label as promo regardless of metadata",
      "urgency": "P0",
      "owner_hint": "Compliance"
    },
    {
      "id": "Q_415",
      "area": "Data",
      "question": "What ensures budget allocation hash includes server timestamp to prevent client clock skew duplicates?",
      "why_it_matters": "C13 Red/CRIT; Q_023 idempotency requires hash stability; client timestamps cause collisions",
      "evidence_anchor": ["agents/budget_allocation_agent.py", "schemas/budget_allocation.zod.ts"],
      "acceptance_signal": "Code: allocation_id = hash(user_id + channels + amounts + server_timestamp); test clock skew scenario",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_416",
      "area": "Risk",
      "question": "What budget cap validation happens at both relative (±25%) and absolute (<$50K single-channel) levels?",
      "why_it_matters": "C13 Red/CRIT; Q_022 requires dual gates; need impl for both percentage and absolute dollar limits",
      "evidence_anchor": ["agents/budget_allocation_agent.py", "config/budget_limits.yml"],
      "acceptance_signal": "Code: validate shift_pct <=25% AND channel_allocation <= 50000; test both boundaries",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_417",
      "area": "Strategy",
      "question": "How does pacing agent detect asset-level overspending when campaign aggregate is within limits?",
      "why_it_matters": "C14 Red/CRIT; Q_024 requires asset granularity; campaign-only checks miss per-asset breaches",
      "evidence_anchor": ["agents/pacing_agent.py", "schemas/pacing_metrics.zod.ts"],
      "acceptance_signal": "Code: check each asset's spend_rate vs budget_rate; pause individual assets if >110%; metric assets_paused",
      "urgency": "P0",
      "owner_hint": "Execution"
    },
    {
      "id": "Q_418",
      "area": "Observability",
      "question": "What distributed trace captures kill-switch trigger latency from user click to ad platform API confirmation?",
      "why_it_matters": "C17 Red/CRIT; Q_028 requires <5s measurement; need end-to-end trace for SLA validation",
      "evidence_anchor": ["agents/activation_agent.py", "core/observability.py"],
      "acceptance_signal": "Trace: span 'kill_switch' with child spans {trigger, queue_flush, api_call, confirmation}; p95 <5s",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_419",
      "area": "Data",
      "question": "How does activation idempotency key incorporate mutation sequence to prevent stale retry duplicates?",
      "why_it_matters": "C17 Red/CRIT; Q_029 requires mutation tracking; 8d TTL means old retries could duplicate",
      "evidence_anchor": ["agents/activation_agent.py", "schemas/activation_request.zod.ts"],
      "acceptance_signal": "Code: idempotency_key = hash(campaign_id + mutation_seq + request_params); increment seq on success",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_420",
      "area": "Infra",
      "question": "What audit log S3 fallback triggers when BigQuery write fails and how is eventual consistency handled?",
      "why_it_matters": "C20 Red/HIGH; Q_078 requires fallback; need impl for S3 write + async replay to BQ",
      "evidence_anchor": ["core/audit.py", "infra/audit_pipeline.yml"],
      "acceptance_signal": "Code: write to S3 on BQ fail; background job replays S3→BQ within 60s; metric audit_fallback_active",
      "urgency": "P0",
      "owner_hint": "Infra"
    },
    {
      "id": "Q_421",
      "area": "Secrets",
      "question": "What HMAC key versioning strategy allows audit log verification across multiple key rotations?",
      "why_it_matters": "C20 Red/HIGH; Q_079 requires 90d rotation; need multi-key store for historical verification",
      "evidence_anchor": ["core/audit.py", "core/secrets.py"],
      "acceptance_signal": "Code: store key_version in audit record; secrets store maintains last 4 keys (1yr retention)",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_422",
      "area": "Observability",
      "question": "What P0 alert routing latency metric tracks threshold evaluation to PagerDuty notification time?",
      "why_it_matters": "Monitor Red/CRIT; Q_144 requires <2min SLA; need end-to-end latency measurement",
      "evidence_anchor": ["core/alerting.py", "core/metrics.py"],
      "acceptance_signal": "Metric: alert_e2e_latency_seconds{severity=P0} with p95 <120s; trace spans for each stage",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_423",
      "area": "Data",
      "question": "How does identity collision rate metric distinguish false positives from true duplicates?",
      "why_it_matters": "C01 Red/CRIT; Q_301 requires precision tracking; need ground truth sampling for validation",
      "evidence_anchor": ["agents/identity_resolution_agent.py", "core/metrics.py"],
      "acceptance_signal": "Metric: identity_false_positive_rate computed via daily sample audit of 1000 matches; alert >0.01%",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_424",
      "area": "Risk",
      "question": "What rollback mechanism handles identity merge initiated during salt rotation grace period?",
      "why_it_matters": "C01 Red/CRIT; Q_302 requires transaction safety; concurrent rotation+merge could orphan hashes",
      "evidence_anchor": ["core/privacy.py", "agents/identity_resolution_agent.py"],
      "acceptance_signal": "Code: detect rotation in-progress via flag; rollback merge if rotation started; retry after rotation completes",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_425",
      "area": "Strategy",
      "question": "What MMM control variable length validation prevents shape mismatch errors during model fitting?",
      "why_it_matters": "C04 Red/HIGH; Q_307 requires array alignment; mismatched control lengths cause silent failures",
      "evidence_anchor": ["agents/mmm_agent.py", "schemas/mmm_training_data.zod.ts"],
      "acceptance_signal": "Schema: assert len(spend)==len(seasonality)==len(price)==len(promo); ValidationError on mismatch",
      "urgency": "P0",
      "owner_hint": "Execution"
    },
    {
      "id": "Q_426",
      "area": "Data",
      "question": "How does MTA k-anonymity suppression aggregate revenue from suppressed users into total without leaking individual data?",
      "why_it_matters": "C05 Red/CRIT; Q_309 requires revenue preservation; suppressed paths still contribute to totals",
      "evidence_anchor": ["agents/mta_agent.py", "schemas/mta_output.zod.ts"],
      "acceptance_signal": "Code: sum revenue from k<10 paths into 'suppressed' aggregate; test 5 users→single suppressed total",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_427",
      "area": "Observability",
      "question": "What audit log entry captures LLM RAG retrieval query inputs for debugging hallucination issues?",
      "why_it_matters": "C10 Red/CRIT; Q_316 requires audit trail; need retrieval_query + source_ids for each LLM call",
      "evidence_anchor": ["agents/llm_council.py", "core/audit.py"],
      "acceptance_signal": "Audit: llm_retrieval event with {query_text, source_ids, retrieval_score, model_version}",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_428",
      "area": "Governance",
      "question": "What schema field exposes Verifier LLM rejection reason to user when output fails validation?",
      "why_it_matters": "C10 Red/CRIT; Q_317 requires transparency; silent retries hide policy violations from users",
      "evidence_anchor": ["agents/llm_council.py", "schemas/llm_output.zod.ts"],
      "acceptance_signal": "Schema: verifier_status{approved, verifier_reason}; API returns reason on rejection",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_429",
      "area": "Risk",
      "question": "What fallback verification tier applies when crisis domain whitelist is stale and no tier-1 sources exist?",
      "why_it_matters": "C11 Red/CRIT; Q_319 requires graceful degradation; strict whitelist blocks legitimate alerts",
      "evidence_anchor": ["agents/crisis_detection_agent.py", "config/official_domains.yml"],
      "acceptance_signal": "Config: fallback_verification=tier2_plus_velocity_gate; requires 5σ spike if no tier-1",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_430",
      "area": "Strategy",
      "question": "How does crisis baseline calculation exclude anomalous spikes to prevent recency bias inflation?",
      "why_it_matters": "C11 Red/CRIT; Q_320 requires outlier removal; including past spikes raises threshold artificially",
      "evidence_anchor": ["agents/crisis_detection_agent.py", "core/metrics.py"],
      "acceptance_signal": "Config: baseline_exclude_anomalies=true; use Tukey fences to remove outliers before computing mean/std",
      "urgency": "P0",
      "owner_hint": "Execution"
    },
    {
      "id": "Q_431",
      "area": "Risk",
      "question": "What minimum sample size gates 3-sigma crisis detection to prevent low-volume false positives?",
      "why_it_matters": "C11 Red/CRIT; Q_321 requires fixed threshold for n<100; high variance causes spurious alerts",
      "evidence_anchor": ["agents/crisis_detection_agent.py", "config/crisis_detection.yml"],
      "acceptance_signal": "Config: min_sample=100; if n<100 use fixed threshold (e.g., 100 mentions/h) instead of 3σ",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_432",
      "area": "Compliance",
      "question": "What email challenge verification prevents minor from self-authorizing COPPA consent using parent's email?",
      "why_it_matters": "C12 Red/CRIT; Q_322 requires parent confirmation; email-only allows circumvention",
      "evidence_anchor": ["middleware/compliance_guard.py", "agents/compliance_agent.py"],
      "acceptance_signal": "Code: send signed token to parent_email; parent must click link + confirm DOB; test self-circumvent scenario",
      "urgency": "P0",
      "owner_hint": "Compliance"
    },
    {
      "id": "Q_433",
      "area": "Data",
      "question": "What exception handling ensures GDPR deletion failure due to FK constraint triggers notification?",
      "why_it_matters": "C12 Red/CRIT; Q_323 requires error visibility; silent FK failures violate GDPR completion guarantee",
      "evidence_anchor": ["core/gdpr.py", "core/alerting.py"],
      "acceptance_signal": "Code: catch FK exception; emit alert with user_id + table; test foreign key violation scenario",
      "urgency": "P0",
      "owner_hint": "Compliance"
    },
    {
      "id": "Q_434",
      "area": "Governance",
      "question": "How does medical claims NLI model detect negation to distinguish 'cures cancer' vs 'does NOT cure cancer'?",
      "why_it_matters": "C12 Red/CRIT; Q_324 requires negation awareness; current NLI may flag safe negated claims",
      "evidence_anchor": ["agents/compliance_agent.py", "models/nli.py"],
      "acceptance_signal": "Code: negation detection via dependency parse or NLI with negation handling; test 'NOT cure'→approved",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_435",
      "area": "Compliance",
      "question": "What precedence rule resolves conflict when Japan promo visual shows 'åºƒå'Š' but metadata says non-promo?",
      "why_it_matters": "C12 Red/CRIT; Q_325 requires clear hierarchy; conflicting signals cause compliance violations",
      "evidence_anchor": ["agents/compliance_agent.py", "config/compliance.yml"],
      "acceptance_signal": "Config: visual_overrides_metadata=true; OCR detection of 'åºƒå'Š' forces promo label regardless of metadata",
      "urgency": "P0",
      "owner_hint": "Compliance"
    },
    {
      "id": "Q_436",
      "area": "Data",
      "question": "What jitter range prevents thundering herd on budget allocation optimistic lock collision retries?",
      "why_it_matters": "C13 Red/CRIT; Q_326 requires backoff; simultaneous retries after lock collision create storms",
      "evidence_anchor": ["agents/budget_allocation_agent.py", "core/retry.py"],
      "acceptance_signal": "Code: jitter = random(100, 500)ms; exponential backoff = base * 2^attempt + jitter; test 10 concurrent retries",
      "urgency": "P0",
      "owner_hint": "Infra"
    },
    {
      "id": "Q_437",
      "area": "Governance",
      "question": "What audit log fields track repeated budget cap breaches to detect gaming or config issues?",
      "why_it_matters": "C13 Red/CRIT; Q_328 requires breach history; repeated violations indicate systemic problem",
      "evidence_anchor": ["agents/budget_allocation_agent.py", "core/audit.py"],
      "acceptance_signal": "Audit: budget_cap_breach event with {user_id, breach_pct, allocation_id, timestamp}; dashboard shows repeat offenders",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_438",
      "area": "Risk",
      "question": "How does pacing agent check sibling asset budgets when pausing one to prevent cascade overspending?",
      "why_it_matters": "C14 Red/CRIT; Q_329 requires aggregate validation; pausing A shifts spend to B/C causing breach",
      "evidence_anchor": ["agents/pacing_agent.py", "schemas/pacing_state.zod.ts"],
      "acceptance_signal": "Code: on pause asset A, check siblings B/C aggregate spend_rate; reject pause if aggregate >100%",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_439",
      "area": "Observability",
      "question": "What metric captures pacing pause latency from breach detection to API confirmation for SLA validation?",
      "why_it_matters": "C14 Red/CRIT; Q_330 requires latency measurement; next-check delay hides actual pause time",
      "evidence_anchor": ["agents/pacing_agent.py", "core/metrics.py"],
      "acceptance_signal": "Metric: pacing_pause_latency_seconds = breach_ts - pause_confirmed_ts; p95 <3600s",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_440",
      "area": "Risk",
      "question": "What queue flush mechanism ensures kill-switch cancels queued activations before they execute?",
      "why_it_matters": "C17 Red/CRIT; Q_331 requires immediate stop; queued items post-kill cause unwanted activations",
      "evidence_anchor": ["agents/activation_agent.py", "core/queue.py"],
      "acceptance_signal": "Code: kill-switch sets stop_flag; queue flush cancels pending items; audit log tracks flushed count",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_441",
      "area": "Data",
      "question": "What rollback strategy handles activation timeout on 3/5 ad platforms to maintain consistent state?",
      "why_it_matters": "C17 Red/CRIT; Q_332 requires all-or-nothing; partial commits create drift across platforms",
      "evidence_anchor": ["agents/activation_agent.py", "schemas/activation_result.zod.ts"],
      "acceptance_signal": "Code: 2-phase commit; if any timeout, rollback all committed platforms; test 3/5 timeout scenario",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_442",
      "area": "Infra",
      "question": "What exponential backoff with jitter prevents activation retry storms across multiple agent instances?",
      "why_it_matters": "C17 Red/CRIT; Q_333 requires distributed coordination; linear backoff causes synchronized retries",
      "evidence_anchor": ["agents/activation_agent.py", "core/retry.py"],
      "acceptance_signal": "Code: backoff = base * 2^attempt + random(0, 1000)ms; global rate limiter across instances",
      "urgency": "P0",
      "owner_hint": "Infra"
    },
    {
      "id": "Q_443",
      "area": "Infra",
      "question": "What S3 write window handles eventual consistency for audit logs before BigQuery replay?",
      "why_it_matters": "C20 Red/HIGH; Q_336 requires consistency guarantee; immediate replay may miss in-flight S3 writes",
      "evidence_anchor": ["core/audit.py", "infra/audit_pipeline.yml"],
      "acceptance_signal": "Config: s3_window=60s; BQ replay waits 60s after S3 write before reading; test out-of-order writes",
      "urgency": "P0",
      "owner_hint": "Infra"
    },
    {
      "id": "Q_444",
      "area": "Secrets",
      "question": "How does audit log HMAC key versioning maintain multiple active keys for historical verification?",
      "why_it_matters": "C20 Red/HIGH; Q_337 requires multi-key support; in-place rotation invalidates past audit records",
      "evidence_anchor": ["core/audit.py", "core/secrets.py"],
      "acceptance_signal": "Code: store key_version in audit record; secrets manager holds last 4 keys; verify using matching version",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_445",
      "area": "Observability",
      "question": "What immediate P0 alert path bypasses batch processing to meet <10s PagerDuty SLA?",
      "why_it_matters": "Monitor Red/CRIT; Q_338 requires zero-delay routing; batch delays violate <2min SLA",
      "evidence_anchor": ["core/alerting.py", "infra/alerting.yml"],
      "acceptance_signal": "Config: p0_delay=0; direct PagerDuty API call on P0; test threshold→PD <10s",
      "urgency": "P0",
      "owner_hint": "Infra"
    },
    {
      "id": "Q_446",
      "area": "Secrets",
      "question": "What KMS key isolation ensures audit HMAC key compromise doesn't expose API credentials?",
      "why_it_matters": "C20 Red/HIGH; Q_348 requires blast radius containment; same KMS creates single point of failure",
      "evidence_anchor": ["core/audit.py", "core/secrets.py"],
      "acceptance_signal": "Config: hmac_kms_id != api_keys_kms_id; separate KMS keys for different purposes",
      "urgency": "P0",
      "owner_hint": "Risk"
    },
    {
      "id": "Q_447",
      "area": "Governance",
      "question": "What RBAC approval time-of-check-time-of-use guard prevents revoked user from approving decisions?",
      "why_it_matters": "C16 Red/HIGH; Q_350 TOCTOU vulnerability; user revoked between decision creation and approval",
      "evidence_anchor": ["agents/approval_agent.py", "core/rbac.py"],
      "acceptance_signal": "Code: re-check approver permissions at grant time; test revoke→immediate reject approval attempt",
      "urgency": "P0",
      "owner_hint": "Governance"
    },
    {
      "id": "Q_448",
      "area": "Data",
      "question": "What atomicity guarantee ensures feature store write failure triggers cache rollback to prevent drift?",
      "why_it_matters": "C03 Yellow; Q_351 online/offline consistency; cache success + store failure creates stale reads",
      "evidence_anchor": ["core/feature_store.py", "tests/core/test_feature_store.py"],
      "acceptance_signal": "Code: 2-phase commit; rollback cache on store error; test store failure→cache rolled back",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_449",
      "area": "Data",
      "question": "What cache TTL bounds offline feature lag to guarantee online/offline parity within 60s?",
      "why_it_matters": "C03 Yellow; Q_352 parity SLA; unbounded TTL allows unbounded drift",
      "evidence_anchor": ["core/feature_store.py", "config/feature_store.yml"],
      "acceptance_signal": "Config: cache_ttl<=60s; test offline update→online reflects <60s",
      "urgency": "P0",
      "owner_hint": "DataOps"
    },
    {
      "id": "Q_450",
      "area": "Strategy",
      "question": "What MMM overfitting detection rejects models with R²>0.95 combined with MAPE>20% as spurious fit?",
      "why_it_matters": "C04 Red; Q_354 requires dual gate; high R² + high MAPE indicates memorization not generalization",
      "evidence_anchor": ["agents/mmm_agent.py", "schemas/mmm_validation.zod.ts"],
      "acceptance_signal": "Code: if r_squared>0.95 AND mape>0.20, raise ValidationError('overfitting'); test synthetic overfit data",
      "urgency": "P0",
      "owner_hint": "Execution"
    }
  ]
}
